=============
Маршрутизация
=============

Пример:

.. code-block:: yaml

    ver: "1.0"
    includes: ["path/to/custom/rule.yml"]
    rules:
      rule_2:
        senders: [calendar]
        before_ext: [num_to_word]
        purposes: [remind]
        acceptors: [silero]
    ...


В данном примере правило работает так:
Все ивенты из модуля `calendar`, чей `purpose` соответсвует `"remind"`, будут преобразованы [расширением](Модули/event_utils.md) `num_to_word` (оно преобразует цифры цифры в текст, т.е. "123" > "сто двадцать три") и переданы на вход модуля `silero` который генерирует озвучку. По сути правило "озвучивает напоминания из календаря".

Keys:
* `ver` - версия файла маршрутизации
* `includes` - названия файлов которые так-же нужно подключить
* `rules` - список правил маршрутизации

Правила маршрутизации содержат несколько ключей определяющих пути и дополнительную обработку ивентов.

Ключ `senders` содержит список названий модулей выходные очереди которых будут прослушиваться для маршрутизации. [Ивенты](Ивенты.md) из очередей этих  будут взяты для применения к ним расширений из списка `before_ext`, но при наличии `purposes` ивенты будут фильтроваться по этому свойству. После применеия расширений ивент будет отправлен в входные очереди модулей содержащиеся в списке `acceptors`.


Расширенный вариант использования расширений может включать параметры расширения для тех расширений которые поддерживают/требуют эту возможность.
Пример использования расширения смены типа ивента:


.. code-block:: yaml

    rule_n:
      senders: [any_module]
      before_ext: [
        any_ext,
        [change_type, {new_type: "user_command"}]
      ]
      purposes: [any_purpose]
      acceptors: [any_module2]


В данном примере есть два расширения: `any_ext` и `change_type`
Расширение `any_ext` - стандартное использование расширения.
`change_type` - расширение представленно в виде списка из двух элементов, где первым элементом передается название расширения, а вторым передается именованый список ключей и их значений - параметров расширения, которые будут переданы в функцию расширения в качестве именованых параметров функции.

Интерфейсы
----------
Модули реализующие интерфейс для взаимодействия с пользователем, если они содержат минимум одну входящюю и одну исходящюю очереди, могут быть настроены таким образом, чтобы модули могли вернуть ответ в тот-же модуль, через который пользователь отправил команду.

Асоции интерфейсов ввода-вывода задаются в файле `connections.yml` в папке connections либо в папке модуля. Для создания асоции надо добавить ключ io_pairs в файл `connections.yml`, он должен содержать пары `ключ: значение`, где ключ - модуль из которого приходит ивент, значение - модуль в входную очередь которого надо вернуть ответ.

Пример:

.. code-block:: yaml

    io_pairs
      vosk: silero

\* ответы которые приходят в vosk перенаправлять в silero

Для возврата ответа нужно вызвать асинхронный метод `.reply()` у ивента - параметром принимает текстовое значение которое будет переданно в виде текстового ивента в ассоциированую выходную очередь.
Пример:

.. code-block:: python

    # после работы модуля/выполнения действий/и т.д.
    await event.reply("Что-то произошло...")
