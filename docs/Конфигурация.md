# Маршрутизация ивентов

Пример:
```yaml
ver: "1.0"
includes: ["path/to/custom/rule.yml"]
rules:
  rule_2:
    senders: [calendar]
    before_ext: [num_to_word]
    purposes: [remind]
    acceptors: [silero]
...
```

В данном примере правило работает так:
Все ивенты из модуля `calendar`, чей `purpose` соответсвует `"remind"`, будут преобразованы [расширением](Модули/event_utils.md) `num_to_word` (оно преобразует цифры цифры в текст, т.е. "123" > "сто двадцать три") и переданы на вход модуля `silero` который генерирует озвучку. По сути правило "озвучивает напоминания из календаря". 

Keys:
* `ver` - версия файла маршрутизации
* `includes` - названия файлов которые так-же нужно подключить
* `rules` - список правил маршрутизации

Правила маршрутизации содержат несколько ключей определяющих пути и дополнительную обработку ивентов.

Ключ `senders` содержит список названий модулей выходные очереди которых будут прослушиваться для маршрутизации. [Ивенты](Ивенты.md) из очередей этих  будут взяты для применения к ним расширений из списка `before_ext`, но при наличии `purposes` ивенты будут фильтроваться по этому свойству. После применеия расширений ивент будет отправлен в входные очереди модулей содержащиеся в списке `acceptors`.


Расширенный вариант использования расширений может включать параметры расширения для тех расширений которые поддерживают/требуют эту возможность.
Пример использования расширения смены типа ивента:
```yaml
rule_n:
  senders: [any_module]
  before_ext: [any_ext, [change_type, {new_type: "user_command"}]]
  purposes: [any_purpose]
  acceptors: [any_module2]
```
В данном примере есть два расширения: `any_ext` и `change_type`
Расширение `any_ext` - стандартное использование расширения.
`change_type` - расширение представленно в виде списка из двух элементов, где первым элементом передается название расширения, а вторым передается именованый список ключей и их значений - параметров расширения, которые будут переданы в функцию расширения в качестве именованых параметров функции.

# Интерфейсы
Модули реализующие интерфейс для взаимодействия с пользователем, если они содержат минимум одну входящюю и одну исходящюю очереди, могут быть настроены таким образом, чтобы модули могли вернуть ответ в тот-же модуль, через который пользователь отправил команду.

Асоции интерфейсов ввода-вывода задаются в файле `connections.yml` в папке connections либо в папке модуля. Для создания асоции надо добавить ключ io_pairs в файл `connections.yml`, он должен содержать пары `ключ: значение`, где ключ - модуль из которого приходит ивент, значение - модуль в входную очередь которого надо вернуть ответ.

Пример:
```yaml
io_pairs
  vosk: silero
```
\* ответы которые приходят в vosk перенаправлять в silero

Для возврата ответа нужно вызвать асинхронный метод `.reply()` у ивента - параметром принимает текстовое значение которое будет переданно в виде текстового ивента в ассоциированую выходную очередь. 
Пример:
```python
# после работы модуля/выполнения действий/и т.д.
await event.reply("Что-то произошло...")
```